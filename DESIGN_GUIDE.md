# MagnetDownload 详细设计指南

## 文档目的
本文档为开发者提供详细的设计指导，说明**如何**设计和实现各个模块，包括具体的设计思路、实现要点、接口设计原则等。开发者可以根据本指南**自行编码实现**。

---

## 第一部分：系统设计思路

### 1.1 整体架构设计思路

#### 核心设计原则
1. **分离关注点**：每个模块只负责一个明确的职责
2. **依赖倒置**：高层模块不依赖低层模块，都依赖于抽象
3. **接口隔离**：客户端不应该依赖它不需要的接口
4. **开闭原则**：对扩展开放，对修改封闭

#### 模块分层逻辑
```
应用层：用户接口、下载管理
    ↓ (使用)
业务层：协议处理、任务调度
    ↓ (使用)  
网络层：连接管理、数据传输
    ↓ (使用)
基础层：事件循环、内存管理、日志
```

**你需要思考的问题**：
- 为什么要这样分层？
- 每层之间如何通信？
- 如何确保层次间的解耦？

### 1.2 线程模型设计思路

#### 多线程事件循环池的设计理由
1. **为什么选择多线程而不是单线程？**
   - 磁力下载需要处理大量并发连接
   - DHT网络查询是I/O密集操作
   - 文件写入操作可能阻塞

2. **为什么是事件循环而不是线程池？**
   - 网络I/O天然适合事件驱动模型
   - 避免大量线程切换开销
   - 简化并发模型，减少锁的使用

**你的实现任务**：
- 设计EventLoopManager类的接口
- 思考如何分配任务到不同的io_context
- 考虑负载均衡策略

---

## 第二部分：模块详细设计

### 2.1 事件循环管理器 (EventLoopManager)

#### 设计目标
管理多个io_context实例，提供统一的任务分发接口，实现负载均衡。

#### 你需要设计的核心接口
```cpp
class EventLoopManager {
public:
    // 构造函数：需要考虑线程数量的确定策略
    // 启动方法：如何安全地启动所有线程
    // 停止方法：如何优雅地停止所有线程
    // 获取io_context：如何实现负载均衡
    // 任务投递：如何确保线程安全
};
```

#### 关键设计问题你需要解决
1. **线程数量确定**：
   - 默认值应该是多少？
   - 是否允许运行时调整？
   - 如何处理硬件资源不足的情况？

2. **负载均衡策略**：
   - 轮询(Round-Robin)
   - 基于任务数量的分配
   - 基于CPU使用率的分配

3. **生命周期管理**：
   - 如何确保所有线程正确启动？
   - 关闭时如何等待所有任务完成？
   - 异常情况下如何处理？

4. **线程安全考虑**：
   - 哪些数据需要原子操作？
   - 哪些操作需要加锁？
   - 如何避免死锁？

#### 实现建议
1. **使用RAII管理资源**：
   - 在构造函数中创建io_context
   - 在析构函数中确保清理

2. **使用work_guard防止io_context退出**：
   - 理解work_guard的作用机制
   - 何时创建和销毁work_guard

3. **实现优雅关闭**：
   - 设置停止标志
   - 等待当前任务完成
   - 清理资源

### 2.2 任务调度器 (TaskScheduler)

#### 设计目标
实现基于优先级的任务调度，防止低优先级任务饥饿，与EventLoopManager集成。

#### 你需要解决的核心设计问题

1. **优先级设计**：
   ```
   CRITICAL: 用户交互、紧急错误处理
   HIGH:     DHT查询、Peer连接建立  
   NORMAL:   数据传输、文件写入
   LOW:      统计收集、日志记录
   ```
   
   **思考**：
   - 为什么是这四个级别？
   - 每个级别应该包含哪些具体操作？
   - 如何在代码中表达这些优先级？

2. **老化机制设计**：
   - 什么时候触发老化？
   - 如何计算老化时间？
   - 老化后如何调整优先级？

3. **数据结构选择**：
   - 使用什么容器存储任务？
   - 如何快速获取最高优先级任务？
   - 如何高效地实现老化检查？

#### 你的实现策略
1. **设计Task结构**：
   - 包含哪些字段？
   - 如何表示任务的元信息？
   - 如何设计比较函数？

2. **线程安全实现**：
   - 任务队列的并发访问如何处理？
   - 读写操作如何同步？
   - 如何避免性能瓶颈？

3. **与EventLoopManager集成**：
   - 如何将调度器的任务分发到io_context？
   - 如何处理跨线程的任务传递？

### 2.3 磁力链接解析器 (MagnetUriParser)

#### 设计目标
解析标准的magnet URI，提取关键信息，处理各种边界情况。

#### 磁力链接格式分析
```
magnet:?xt=urn:btih:[info_hash]&dn=[display_name]&tr=[tracker_url]&xl=[file_length]
```

#### 你需要处理的解析挑战
1. **URL编码解码**：
   - 如何处理特殊字符？
   - 中文文件名如何处理？
   - 空格和其他字符如何转义？

2. **参数提取策略**：
   - 如何分离各个参数？
   - 重复参数如何处理？
   - 未知参数如何处理？

3. **错误处理设计**：
   - 哪些情况算作解析失败？
   - 如何返回详细的错误信息？
   - 部分解析成功如何处理？

#### 你的设计任务
1. **数据结构设计**：
   ```cpp
   struct MagnetInfo {
       // 必需字段
       // 可选字段  
       // 错误信息
       // 验证方法
   };
   ```

2. **解析算法设计**：
   - 状态机方式还是正则表达式？
   - 如何确保性能和正确性？
   - 如何处理畸形URI？

3. **接口设计**：
   - 如何表达解析结果？
   - 如何处理解析错误？
   - 是否需要流式解析？

### 2.4 DHT客户端 (DHTClient)

#### 设计目标
实现简化的DHT协议，能够连接到DHT网络，查找peer节点。

#### DHT协议核心概念
1. **节点ID**：160位标识符
2. **距离计算**：XOR距离
3. **K-bucket**：路由表结构
4. **消息类型**：ping、find_node、get_peers、announce_peer

#### 你需要设计的核心功能

1. **节点管理**：
   - 如何存储节点信息？
   - 如何计算节点距离？
   - 如何维护节点的活跃状态？

2. **路由表设计**：
   - K-bucket如何实现？
   - 节点如何分桶？
   - 路由表如何更新？

3. **消息处理**：
   - 如何序列化/反序列化消息？
   - 如何处理网络字节序？
   - 如何实现消息的请求/响应配对？

4. **网络通信**：
   - 如何集成到异步框架？
   - 超时如何处理？
   - 错误重试策略？

#### 你的实现策略
1. **从简单开始**：
   - 先实现ping/pong
   - 再实现find_node
   - 最后实现get_peers

2. **消息格式**：
   - 研究bencode编码
   - 设计消息结构体
   - 实现序列化函数

3. **状态管理**：
   - 设计DHT客户端的状态机
   - 处理引导过程
   - 维护网络连接状态

### 2.5 Peer连接管理器 (PeerManager)

#### 设计目标
管理与peer节点的TCP连接，实现BitTorrent协议，协调数据下载。

#### BitTorrent协议要点
1. **握手过程**：协议标识、info_hash、peer_id交换
2. **消息类型**：choke、unchoke、interested、not_interested、have、bitfield、request、piece、cancel
3. **状态管理**：choked/unchoked、interested/not_interested

#### 你需要解决的设计问题

1. **连接生命周期**：
   - 如何建立连接？
   - 如何处理连接断开？
   - 如何重连？

2. **协议状态机**：
   - 握手状态如何管理？
   - 消息收发如何同步？
   - 错误状态如何处理？

3. **数据请求策略**：
   - 如何选择要下载的piece？
   - 如何平衡不同peer的负载？
   - 如何处理慢速peer？

#### 你的实现规划
1. **连接抽象**：
   - 设计PeerConnection类
   - 封装TCP连接细节
   - 实现消息收发接口

2. **协议实现**：
   - 分步实现各种消息类型
   - 处理二进制协议细节
   - 实现消息解析和生成

3. **管理策略**：
   - 连接池管理
   - 下载调度算法
   - 性能监控

---

## 第三部分：实现指导

### 3.1 开发顺序建议

#### 阶段1：基础框架
1. **EventLoopManager**：
   - 先实现单线程版本
   - 验证基本的任务投递功能
   - 再扩展到多线程

2. **TaskScheduler**：
   - 先实现简单的FIFO队列
   - 添加优先级支持
   - 最后实现老化机制

#### 阶段2：协议解析
1. **MagnetUriParser**：
   - 先处理标准格式
   - 逐步添加容错处理
   - 完善错误报告

#### 阶段3：网络功能
1. **基础UDP通信**：
   - 实现简单的收发功能
   - 集成到事件循环
   - 添加错误处理

2. **DHT客户端**：
   - 实现消息编解码
   - 实现基本查询功能
   - 完善路由表管理

### 3.2 测试策略

#### 单元测试重点
1. **算法正确性**：
   - 优先级调度算法
   - DHT距离计算
   - 磁力链接解析

2. **边界条件**：
   - 空输入处理
   - 异常格式处理
   - 资源耗尽情况

#### 集成测试重点
1. **组件协作**：
   - 事件循环与调度器
   - 网络层与协议层
   - 错误传播机制

2. **性能测试**：
   - 并发连接数
   - 内存使用情况
   - CPU利用率

### 3.3 调试和监控设计

#### 日志系统设计
1. **日志级别**：
   - TRACE：详细的执行流程
   - DEBUG：调试信息
   - INFO：重要事件
   - WARN：警告信息
   - ERROR：错误信息

2. **日志内容设计**：
   - 时间戳
   - 线程ID
   - 模块名称
   - 消息内容
   - 上下文信息

#### 性能监控设计
1. **关键指标**：
   - 任务队列长度
   - 连接数量
   - 数据传输速率
   - 错误率

2. **监控实现**：
   - 统计数据收集
   - 定期报告机制
   - 异常检测

---

## 第四部分：关键技术点

### 4.1 异步编程模式

#### 回调链管理
1. **避免回调地狱**：
   - 将复杂回调分解为小函数
   - 使用shared_ptr管理对象生命周期
   - 考虑使用promise/future

2. **错误传播**：
   - 设计统一的错误处理接口
   - 实现错误码和异常的转换
   - 确保错误不会被忽略

#### 内存管理
1. **对象生命周期**：
   - 在异步操作中如何确保对象存活？
   - 何时使用shared_ptr vs unique_ptr？
   - 如何打破循环引用？

2. **资源清理**：
   - RAII原则的应用
   - 异常安全的资源管理
   - 优雅关闭的实现

### 4.2 网络编程要点

#### 协议设计
1. **消息格式**：
   - 如何设计高效的序列化？
   - 如何处理网络字节序？
   - 如何版本化协议？

2. **状态同步**：
   - 如何确保协议状态一致？
   - 如何处理状态不匹配？
   - 如何实现状态恢复？

#### 性能优化
1. **网络I/O**：
   - 如何减少系统调用？
   - 如何实现零拷贝？
   - 如何优化缓冲区使用？

2. **并发控制**：
   - 如何避免锁竞争？
   - 何时使用无锁数据结构？
   - 如何设计线程安全的接口？

---

## 第五部分：扩展性设计

### 5.1 协议扩展架构

#### 插件机制设计
1. **接口抽象**：
   ```cpp
   class IProtocolHandler {
       // 统一的协议接口
       // 生命周期管理
       // 状态查询接口
   };
   ```

2. **工厂模式应用**：
   - 如何注册新的协议处理器？
   - 如何根据URI类型选择处理器？
   - 如何管理处理器的生命周期？

#### 配置驱动设计
1. **配置系统**：
   - 支持哪些配置项？
   - 如何实现配置热加载？
   - 如何验证配置的有效性？

2. **参数化设计**：
   - 哪些硬编码值应该配置化？
   - 如何设计合理的默认值？
   - 如何处理配置冲突？

### 5.2 协程扩展准备

#### 接口设计考虑
1. **Future兼容性**：
   - 如何设计回调接口使其易于协程化？
   - 如何统一错误处理模式？
   - 如何保持性能优势？

2. **生命周期管理**：
   - 协程中如何管理对象生命周期？
   - 如何处理协程的取消？
   - 如何实现协程间的通信？

---

## 总结

本设计指南为你提供了完整的设计思路和实现策略。记住：

1. **从简单开始**：每个模块都先实现最基本的功能
2. **测试驱动**：写代码前先想清楚如何测试
3. **迭代改进**：功能正确性优先，然后优化性能
4. **文档先行**：设计接口时先写注释说明意图

你现在可以根据这个指南开始你的编码实现了！建议从EventLoopManager的单线程版本开始，逐步构建整个系统。
