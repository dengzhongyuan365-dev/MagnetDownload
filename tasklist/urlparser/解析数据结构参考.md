# Magnet URI 解析器数据结构设计

> **目标**：设计合理的数据结构来存储解析结果，便于后续模块使用

---

## 1. 设计原则

### 1.1 核心原则

1. **类型安全**：使用强类型，避免字符串传递错误
2. **明确语义**：字段名清晰表达含义
3. **便于使用**：后续模块直接使用，无需二次转换
4. **内存高效**：避免不必要的拷贝和分配
5. **可扩展**：预留扩展空间

### 1.2 使用场景分析

```
解析结果会被以下模块使用：

1. DHTClient
   - 需要：InfoHash（20字节二进制）
   - 用途：在 DHT 网络查找 Peer

2. TrackerClient  
   - 需要：InfoHash + Tracker URL 列表
   - 用途：向 Tracker 查询 Peer

3. PeerManager
   - 需要：InfoHash（握手验证）
   - 用途：与 Peer 建立连接

4. DownloadManager
   - 需要：所有信息
   - 用途：管理下载任务，显示进度

5. UI/CLI
   - 需要：Display Name, File Length
   - 用途：显示给用户
```

---

## 2. 数据结构设计

### 2.1 InfoHash 类型

**为什么需要专门的类型**：
- InfoHash 是 20 字节的二进制数据
- 需要频繁传递和比较
- 需要支持哈希表存储（作为 key）

```cpp
namespace magnet {

// InfoHash: 20 字节的 SHA-1 哈希值
class InfoHash {
public:
    static constexpr size_t SIZE = 20;
    using ByteArray = std::array<uint8_t, SIZE>;
    
    // 构造函数
    InfoHash() = default;
    explicit InfoHash(const ByteArray& bytes) : data_(bytes) {}
    
    // 从十六进制字符串构造（40个字符）
    static std::optional<InfoHash> from_hex(std::string_view hex);
    
    // 从 Base32 字符串构造（32个字符）
    static std::optional<InfoHash> from_base32(std::string_view base32);
    
    // 转换为十六进制字符串
    std::string to_hex() const;
    
    // 获取原始字节
    const ByteArray& bytes() const { return data_; }
    ByteArray& bytes() { return data_; }
    
    // 比较操作
    bool operator==(const InfoHash& other) const {
        return data_ == other.data_;
    }
    
    bool operator!=(const InfoHash& other) const {
        return data_ != other.data_;
    }
    
    bool operator<(const InfoHash& other) const {
        return data_ < other.data_;
    }
    
    // 支持作为 unordered_map 的 key
    struct Hash {
        size_t operator()(const InfoHash& hash) const {
            // 使用前 8 字节作为哈希值
            size_t result = 0;
            std::memcpy(&result, hash.data_.data(), sizeof(size_t));
            return result;
        }
    };
    
private:
    ByteArray data_{};
};

} // namespace magnet
```

**使用示例**：
```cpp
// DHT 查询
dht_client.find_peers(magnet_info.info_hash(), callback);

// 作为 map 的 key
std::unordered_map<InfoHash, DownloadTask, InfoHash::Hash> tasks;

// 比较
if (received_hash == expected_hash) { /* ... */ }
```

---

### 2.2 MagnetInfo 结构

**核心数据结构**：存储解析后的所有信息

```cpp
namespace magnet {

struct MagnetInfo {
    // ========== 必需字段 ==========
    
    // InfoHash（20字节 SHA-1 哈希）
    InfoHash info_hash;
    
    
    // ========== 可选字段 ==========
    
    // 显示名称（用于 UI 显示和默认文件名）
    std::optional<std::string> display_name;
    
    // Tracker URL 列表（用于备选 Peer 发现）
    std::vector<std::string> trackers;
    
    // 文件大小（字节）
    std::optional<uint64_t> exact_length;
    
    // Web seed URL 列表（HTTP/HTTPS 下载源）
    std::vector<std::string> web_seeds;
    
    // .torrent 文件 URL 列表
    std::vector<std::string> exact_sources;
    
    // 关键词列表（用于搜索）
    std::vector<std::string> keywords;
    
    
    // ========== 辅助方法 ==========
    
    // 检查是否有效（InfoHash 不为空）
    bool is_valid() const {
        // 检查 InfoHash 是否全为 0
        return info_hash.bytes() != InfoHash::ByteArray{};
    }
    
    // 获取显示名称（如果没有则返回 InfoHash 的十六进制）
    std::string get_display_name() const {
        if (display_name.has_value() && !display_name->empty()) {
            return *display_name;
        }
        return info_hash.to_hex();
    }
    
    // 是否有 Tracker
    bool has_trackers() const {
        return !trackers.empty();
    }
    
    // 是否有 Web seeds
    bool has_web_seeds() const {
        return !web_seeds.empty();
    }
    
    // 是否知道文件大小
    bool has_exact_length() const {
        return exact_length.has_value();
    }
};

} // namespace magnet
```

---

### 2.3 解析结果类型

**为什么需要 Result 类型**：
- 解析可能失败，需要返回错误信息
- 避免使用异常（性能考虑）
- 提供详细的错误信息

```cpp
namespace magnet {

// 解析错误类型
enum class ParseError {
    INVALID_SCHEME,         // 不是 magnet: 协议
    MISSING_INFO_HASH,      // 缺少 xt 参数
    INVALID_INFO_HASH,      // InfoHash 格式错误
    INVALID_HEX_ENCODING,   // 十六进制编码错误
    INVALID_BASE32_ENCODING,// Base32 编码错误
    INVALID_URL_ENCODING,   // URL 编码错误
    INVALID_TRACKER_URL,    // Tracker URL 格式错误
    INVALID_LENGTH_VALUE,   // 文件大小格式错误
    EMPTY_URI               // 空的 URI
};

// 错误信息
struct ParseErrorInfo {
    ParseError error;
    std::string message;
    size_t position;  // 错误发生的位置（如果适用）
    
    ParseErrorInfo(ParseError err, std::string msg, size_t pos = 0)
        : error(err), message(std::move(msg)), position(pos) {}
};

// 解析结果（使用 std::variant 或自定义 Result 类型）
using ParseResult = std::variant<MagnetInfo, ParseErrorInfo>;

// 或者使用更明确的 Result 类型
template<typename T, typename E>
class Result {
public:
    // 成功构造
    static Result ok(T value) {
        return Result(std::move(value));
    }
    
    // 失败构造
    static Result err(E error) {
        return Result(std::move(error));
    }
    
    // 检查是否成功
    bool is_ok() const { return std::holds_alternative<T>(data_); }
    bool is_err() const { return std::holds_alternative<E>(data_); }
    
    // 获取值（如果成功）
    T& value() { return std::get<T>(data_); }
    const T& value() const { return std::get<T>(data_); }
    
    // 获取错误（如果失败）
    E& error() { return std::get<E>(data_); }
    const E& error() const { return std::get<E>(data_); }
    
    // 获取值或默认值
    T value_or(T default_value) const {
        return is_ok() ? value() : std::move(default_value);
    }
    
private:
    explicit Result(T value) : data_(std::move(value)) {}
    explicit Result(E error) : data_(std::move(error)) {}
    
    std::variant<T, E> data_;
};

// 使用别名
using MagnetParseResult = Result<MagnetInfo, ParseErrorInfo>;

} // namespace magnet
```

**使用示例**：
```cpp
auto result = parser.parse(magnet_uri);

if (result.is_ok()) {
    const auto& info = result.value();
    // 使用解析结果
    dht_client.find_peers(info.info_hash, callback);
} else {
    const auto& error = result.error();
    std::cerr << "解析失败: " << error.message << std::endl;
}
```

---

## 3. 完整的头文件设计

```cpp
// include/magnet/protocols/magnet_types.h

#pragma once

#include <array>
#include <string>
#include <string_view>
#include <vector>
#include <optional>
#include <variant>
#include <cstdint>
#include <cstring>

namespace magnet {

// ========== InfoHash 类型 ==========

class InfoHash {
public:
    static constexpr size_t SIZE = 20;
    using ByteArray = std::array<uint8_t, SIZE>;
    
    InfoHash() = default;
    explicit InfoHash(const ByteArray& bytes);
    
    static std::optional<InfoHash> from_hex(std::string_view hex);
    static std::optional<InfoHash> from_base32(std::string_view base32);
    
    std::string to_hex() const;
    
    const ByteArray& bytes() const { return data_; }
    ByteArray& bytes() { return data_; }
    
    bool operator==(const InfoHash& other) const;
    bool operator!=(const InfoHash& other) const;
    bool operator<(const InfoHash& other) const;
    
    struct Hash {
        size_t operator()(const InfoHash& hash) const;
    };
    
private:
    ByteArray data_{};
};


// ========== MagnetInfo 结构 ==========

struct MagnetInfo {
    // 必需字段
    InfoHash info_hash;
    
    // 可选字段
    std::optional<std::string> display_name;
    std::vector<std::string> trackers;
    std::optional<uint64_t> exact_length;
    std::vector<std::string> web_seeds;
    std::vector<std::string> exact_sources;
    std::vector<std::string> keywords;
    
    // 辅助方法
    bool is_valid() const;
    std::string get_display_name() const;
    bool has_trackers() const;
    bool has_web_seeds() const;
    bool has_exact_length() const;
};


// ========== 解析错误类型 ==========

enum class ParseError {
    INVALID_SCHEME,
    MISSING_INFO_HASH,
    INVALID_INFO_HASH,
    INVALID_HEX_ENCODING,
    INVALID_BASE32_ENCODING,
    INVALID_URL_ENCODING,
    INVALID_TRACKER_URL,
    INVALID_LENGTH_VALUE,
    EMPTY_URI
};

struct ParseErrorInfo {
    ParseError error;
    std::string message;
    size_t position;
    
    ParseErrorInfo(ParseError err, std::string msg, size_t pos = 0);
};


// ========== Result 类型 ==========

template<typename T, typename E>
class Result {
public:
    static Result ok(T value);
    static Result err(E error);
    
    bool is_ok() const;
    bool is_err() const;
    
    T& value();
    const T& value() const;
    
    E& error();
    const E& error() const;
    
    T value_or(T default_value) const;
    
private:
    explicit Result(T value);
    explicit Result(E error);
    
    std::variant<T, E> data_;
};

using MagnetParseResult = Result<MagnetInfo, ParseErrorInfo>;

} // namespace magnet
```

---

## 4. 解析器接口设计

```cpp
// include/magnet/protocols/magnet_uri_parser.h

#pragma once

#include "magnet_types.h"
#include <string_view>

namespace magnet {

class MagnetUriParser {
public:
    MagnetUriParser() = default;
    
    // 解析 Magnet URI
    MagnetParseResult parse(std::string_view uri);
    
private:
    // 内部解析方法
    bool validate_scheme(std::string_view uri);
    std::vector<std::pair<std::string, std::string>> split_parameters(std::string_view query);
    
    std::optional<InfoHash> extract_info_hash(const std::vector<std::pair<std::string, std::string>>& params);
    std::optional<std::string> extract_display_name(const std::vector<std::pair<std::string, std::string>>& params);
    std::vector<std::string> extract_trackers(const std::vector<std::pair<std::string, std::string>>& params);
    std::optional<uint64_t> extract_exact_length(const std::vector<std::pair<std::string, std::string>>& params);
    
    // 辅助方法
    std::string url_decode(std::string_view encoded);
    std::optional<InfoHash> parse_info_hash_value(std::string_view value);
};

} // namespace magnet
```

---

## 5. 使用示例

### 5.1 基本使用

```cpp
#include "magnet/protocols/magnet_uri_parser.h"

using namespace magnet;

int main() {
    MagnetUriParser parser;
    
    std::string uri = "magnet:?xt=urn:btih:ABCDEF1234567890ABCDEF1234567890ABCDEF12"
                      "&dn=example.mp4"
                      "&tr=udp://tracker.example.com:80"
                      "&xl=1234567890";
    
    auto result = parser.parse(uri);
    
    if (result.is_ok()) {
        const auto& info = result.value();
        
        std::cout << "InfoHash: " << info.info_hash.to_hex() << std::endl;
        std::cout << "文件名: " << info.get_display_name() << std::endl;
        
        if (info.has_exact_length()) {
            std::cout << "大小: " << *info.exact_length << " 字节" << std::endl;
        }
        
        if (info.has_trackers()) {
            std::cout << "Trackers:" << std::endl;
            for (const auto& tracker : info.trackers) {
                std::cout << "  - " << tracker << std::endl;
            }
        }
    } else {
        const auto& error = result.error();
        std::cerr << "解析失败: " << error.message << std::endl;
    }
    
    return 0;
}
```

### 5.2 在 DownloadManager 中使用

```cpp
class DownloadManager {
public:
    TaskId start_download(const std::string& magnet_uri, const std::string& save_path) {
        // 1. 解析 Magnet URI
        MagnetUriParser parser;
        auto result = parser.parse(magnet_uri);
        
        if (result.is_err()) {
            throw std::runtime_error("无效的磁力链接: " + result.error().message);
        }
        
        const auto& info = result.value();
        
        // 2. 创建下载任务
        auto task_id = generate_task_id();
        auto task = std::make_shared<DownloadTask>();
        task->id = task_id;
        task->info_hash = info.info_hash;  // 直接使用 InfoHash 对象
        task->display_name = info.get_display_name();
        task->save_path = save_path;
        
        if (info.has_exact_length()) {
            task->expected_size = *info.exact_length;
        }
        
        tasks_[task_id] = task;
        
        // 3. 开始查找 Peer
        find_peers(task, info);
        
        return task_id;
    }
    
private:
    void find_peers(std::shared_ptr<DownloadTask> task, const MagnetInfo& info) {
        // 使用 DHT 查找
        dht_client_.find_peers(info.info_hash, [this, task](std::vector<PeerInfo> peers) {
            on_peers_found(task, peers);
        });
        
        // 使用 Tracker 查找（如果有）
        if (info.has_trackers()) {
            for (const auto& tracker_url : info.trackers) {
                tracker_client_.announce(tracker_url, info.info_hash, 
                    [this, task](std::vector<PeerInfo> peers) {
                        on_peers_found(task, peers);
                    });
            }
        }
    }
};
```

### 5.3 在 DHTClient 中使用

```cpp
class DHTClient {
public:
    void find_peers(const InfoHash& info_hash, PeerListCallback callback) {
        // 直接使用 InfoHash 的二进制数据
        const auto& hash_bytes = info_hash.bytes();
        
        // 构造 DHT get_peers 查询
        BencodeDict query;
        query["id"] = node_id_;
        query["info_hash"] = std::string(
            reinterpret_cast<const char*>(hash_bytes.data()), 
            hash_bytes.size()
        );
        
        // 发送查询
        send_query("get_peers", query, callback);
    }
};
```

### 5.4 在 PeerManager 中使用

```cpp
class PeerManager {
public:
    void connect_to_peer(const PeerInfo& peer, const InfoHash& info_hash, 
                         ConnectCallback callback) {
        // 建立 TCP 连接
        auto socket = std::make_shared<asio::ip::tcp::socket>(io_context_);
        
        socket->async_connect(peer.endpoint, [this, socket, info_hash, callback]
                              (const asio::error_code& ec) {
            if (ec) {
                callback(nullptr);
                return;
            }
            
            // 发送握手消息（包含 InfoHash）
            send_handshake(socket, info_hash, callback);
        });
    }
    
private:
    void send_handshake(std::shared_ptr<asio::ip::tcp::socket> socket,
                        const InfoHash& info_hash,
                        ConnectCallback callback) {
        // 构造握手消息
        std::array<uint8_t, 68> handshake;
        
        // 协议标识
        handshake[0] = 19;
        std::memcpy(&handshake[1], "BitTorrent protocol", 19);
        
        // 保留字节
        std::memset(&handshake[20], 0, 8);
        
        // InfoHash（直接使用二进制数据）
        std::memcpy(&handshake[28], info_hash.bytes().data(), 20);
        
        // Peer ID
        std::memcpy(&handshake[48], peer_id_.data(), 20);
        
        // 发送握手
        asio::async_write(*socket, asio::buffer(handshake),
            [socket, callback](const asio::error_code& ec, size_t) {
                if (!ec) {
                    callback(std::make_shared<PeerConnection>(socket));
                } else {
                    callback(nullptr);
                }
            });
    }
};
```

---

## 6. 设计优势总结

### 6.1 类型安全

```cpp
// ✅ 好：类型安全，编译时检查
void find_peers(const InfoHash& hash);

// ❌ 差：字符串传递，容易出错
void find_peers(const std::string& hash_hex);
```

### 6.2 内存高效

```cpp
// InfoHash 使用 std::array，栈分配，无堆开销
InfoHash hash;  // 20 字节，栈上

// 可选字段使用 std::optional，不占用额外空间
std::optional<std::string> name;  // 只在有值时分配
```

### 6.3 易于使用

```cpp
// 直接使用，无需转换
dht_client.find_peers(info.info_hash, callback);

// 辅助方法简化常见操作
std::cout << info.get_display_name();  // 自动处理空值
```

### 6.4 错误处理清晰

```cpp
auto result = parser.parse(uri);
if (result.is_err()) {
    // 详细的错误信息
    std::cerr << result.error().message << std::endl;
}
```

### 6.5 可扩展

```cpp
// 添加新参数很容易
struct MagnetInfo {
    // ... 现有字段
    
    // 新增字段
    std::vector<std::string> new_parameter;
};
```

---

## 7. 总结

**数据结构设计的关键点**：

1. **InfoHash 使用专门的类型**：
   - 20 字节的 `std::array`
   - 支持十六进制和 Base32 转换
   - 可作为 map 的 key

2. **MagnetInfo 结构清晰**：
   - 必需字段：`InfoHash`
   - 可选字段：使用 `std::optional` 和 `std::vector`
   - 辅助方法：简化常见操作

3. **Result 类型处理错误**：
   - 避免异常
   - 提供详细错误信息
   - 类型安全

4. **直接可用**：
   - 后续模块无需转换
   - 类型安全
   - 性能高效

这样的设计既满足了功能需求，又保证了代码质量和性能！
