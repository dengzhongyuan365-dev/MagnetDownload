# å•å…ƒæµ‹è¯•ç”¨ä¾‹è®¾è®¡è¯¦è§£

> **ç›®æ ‡**ï¼šè¯¦ç»†è¯´æ˜å„æ¨¡å—çš„æµ‹è¯•ç”¨ä¾‹è®¾è®¡
> 
> **æ›´æ–°æ—¶é—´**ï¼š2025-12-31

---

## ğŸ“‹ ç›®å½•

1. [MagnetUriParser æµ‹è¯•ç”¨ä¾‹](#1-magneturiparser-æµ‹è¯•ç”¨ä¾‹)
2. [Bencode æµ‹è¯•ç”¨ä¾‹](#2-bencode-æµ‹è¯•ç”¨ä¾‹)
3. [UdpClient æµ‹è¯•ç”¨ä¾‹](#3-udpclient-æµ‹è¯•ç”¨ä¾‹)
4. [æµ‹è¯•è¦†ç›–ç‡ç›®æ ‡](#4-æµ‹è¯•è¦†ç›–ç‡ç›®æ ‡)

---

## 1. MagnetUriParser æµ‹è¯•ç”¨ä¾‹

### 1.1 åŠŸèƒ½æµ‹è¯•ï¼ˆHappy Pathï¼‰

**æµ‹è¯•ç›®æ ‡**ï¼šéªŒè¯æ­£å¸¸æƒ…å†µä¸‹çš„åŠŸèƒ½

#### æµ‹è¯•ç”¨ä¾‹ 1ï¼šè§£ææ ‡å‡†ç£åŠ›é“¾æ¥

```cpp
TEST(MagnetParserTest, ParseStandardMagnetUri) {
    std::string uri = "magnet:?xt=urn:btih:ABCDEF1234567890&dn=test.mp4&tr=http://tracker.com";
    
    auto result = MagnetUriParser::parse(uri);
    
    ASSERT_TRUE(result.is_ok());
    const auto& info = result.value();
    
    EXPECT_EQ(info.info_hash.to_hex(), "ABCDEF1234567890");
    EXPECT_EQ(info.display_name, "test.mp4");
    EXPECT_EQ(info.trackers.size(), 1);
    EXPECT_EQ(info.trackers[0], "http://tracker.com");
}
```

**éªŒè¯ç‚¹**ï¼š
- âœ… æ­£ç¡®è§£æ info_hash
- âœ… æ­£ç¡®è§£æ display_name
- âœ… æ­£ç¡®è§£æ tracker

#### æµ‹è¯•ç”¨ä¾‹ 2ï¼šè§£æåŒ…å«å¤šä¸ª tracker çš„ç£åŠ›é“¾æ¥

```cpp
TEST(MagnetParserTest, ParseMultipleTrackers) {
    std::string uri = "magnet:?xt=urn:btih:ABC&tr=http://t1.com&tr=http://t2.com&tr=udp://t3.com:6881";
    
    auto result = MagnetUriParser::parse(uri);
    
    ASSERT_TRUE(result.is_ok());
    const auto& trackers = result.value().trackers;
    
    EXPECT_EQ(trackers.size(), 3);
    EXPECT_EQ(trackers[0], "http://t1.com");
    EXPECT_EQ(trackers[1], "http://t2.com");
    EXPECT_EQ(trackers[2], "udp://t3.com:6881");
}
```

**éªŒè¯ç‚¹**ï¼š
- âœ… æ”¯æŒå¤šä¸ª tracker
- âœ… æ”¯æŒä¸åŒåè®®ï¼ˆhttpã€udpï¼‰
- âœ… tracker é¡ºåºä¿æŒ

#### æµ‹è¯•ç”¨ä¾‹ 3ï¼šè§£æåŒ…å« URL ç¼–ç çš„ç£åŠ›é“¾æ¥

```cpp
TEST(MagnetParserTest, ParseUrlEncodedName) {
    // "æµ‹è¯•æ–‡ä»¶.mp4" çš„ URL ç¼–ç 
    std::string uri = "magnet:?xt=urn:btih:ABC&dn=%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6.mp4";
    
    auto result = MagnetUriParser::parse(uri);
    
    ASSERT_TRUE(result.is_ok());
    EXPECT_EQ(result.value().display_name, "æµ‹è¯•æ–‡ä»¶.mp4");
}
```

**éªŒè¯ç‚¹**ï¼š
- âœ… æ­£ç¡®è§£ç  URL ç¼–ç 
- âœ… æ”¯æŒ UTF-8 å­—ç¬¦
- âœ… æ”¯æŒç‰¹æ®Šå­—ç¬¦


### 1.2 è¾¹ç•Œæ¡ä»¶æµ‹è¯•

**æµ‹è¯•ç›®æ ‡**ï¼šéªŒè¯è¾¹ç•Œæƒ…å†µ

#### æµ‹è¯•ç”¨ä¾‹ 4ï¼šæœ€å°æœ‰æ•ˆç£åŠ›é“¾æ¥ï¼ˆåªæœ‰ info_hashï¼‰

```cpp
TEST(MagnetParserTest, ParseMinimalMagnetUri) {
    std::string uri = "magnet:?xt=urn:btih:ABCDEF1234567890ABCDEF1234567890ABCDEF12";
    
    auto result = MagnetUriParser::parse(uri);
    
    ASSERT_TRUE(result.is_ok());
    EXPECT_TRUE(result.value().display_name.empty());
    EXPECT_TRUE(result.value().trackers.empty());
    EXPECT_FALSE(result.value().info_hash.to_hex().empty());
}
```

**éªŒè¯ç‚¹**ï¼š
- âœ… åªæœ‰ info_hash ä¹Ÿæ˜¯æœ‰æ•ˆçš„
- âœ… å¯é€‰å‚æ•°ä¸ºç©º

#### æµ‹è¯•ç”¨ä¾‹ 5ï¼šè¶…é•¿ç£åŠ›é“¾æ¥

```cpp
TEST(MagnetParserTest, ParseVeryLongMagnetUri) {
    std::string uri = "magnet:?xt=urn:btih:ABC";
    
    // æ·»åŠ  1000 ä¸ª tracker
    for (int i = 0; i < 1000; ++i) {
        uri += "&tr=http://tracker" + std::to_string(i) + ".com";
    }
    
    auto result = MagnetUriParser::parse(uri);
    
    ASSERT_TRUE(result.is_ok());
    EXPECT_EQ(result.value().trackers.size(), 1000);
}
```

**éªŒè¯ç‚¹**ï¼š
- âœ… æ”¯æŒå¤§é‡ tracker
- âœ… æ€§èƒ½å¯æ¥å—

#### æµ‹è¯•ç”¨ä¾‹ 6ï¼šç©ºå­—ç¬¦ä¸²

```cpp
TEST(MagnetParserTest, ParseEmptyString) {
    auto result = MagnetUriParser::parse("");
    
    ASSERT_TRUE(result.is_err());
    EXPECT_EQ(result.error(), ParseError::EmptyInput);
}
```

**éªŒè¯ç‚¹**ï¼š
- âœ… æ­£ç¡®å¤„ç†ç©ºè¾“å…¥
- âœ… è¿”å›åˆé€‚çš„é”™è¯¯ç 

#### æµ‹è¯•ç”¨ä¾‹ 7ï¼šè¶…é•¿æ–‡ä»¶å

```cpp
TEST(MagnetParserTest, ParseVeryLongDisplayName) {
    std::string long_name(10000, 'x');  // 10000 ä¸ªå­—ç¬¦
    std::string uri = "magnet:?xt=urn:btih:ABC&dn=" + long_name;
    
    auto result = MagnetUriParser::parse(uri);
    
    ASSERT_TRUE(result.is_ok());
    EXPECT_EQ(result.value().display_name, long_name);
}
```

**éªŒè¯ç‚¹**ï¼š
- âœ… æ”¯æŒè¶…é•¿æ–‡ä»¶å
- âœ… ä¸ä¼šå´©æºƒæˆ–å†…å­˜æº¢å‡º


### 1.3 é”™è¯¯å¤„ç†æµ‹è¯•

**æµ‹è¯•ç›®æ ‡**ï¼šéªŒè¯é”™è¯¯æƒ…å†µçš„å¤„ç†

#### æµ‹è¯•ç”¨ä¾‹ 8ï¼šç¼ºå°‘ magnet: å‰ç¼€

```cpp
TEST(MagnetParserTest, ParseMissingMagnetPrefix) {
    std::string uri = "xt=urn:btih:ABC";
    
    auto result = MagnetUriParser::parse(uri);
    
    ASSERT_TRUE(result.is_err());
    EXPECT_EQ(result.error(), ParseError::InvalidScheme);
}
```

#### æµ‹è¯•ç”¨ä¾‹ 9ï¼šç¼ºå°‘ info_hash

```cpp
TEST(MagnetParserTest, ParseMissingInfoHash) {
    std::string uri = "magnet:?dn=test.mp4&tr=http://tracker.com";
    
    auto result = MagnetUriParser::parse(uri);
    
    ASSERT_TRUE(result.is_err());
    EXPECT_EQ(result.error(), ParseError::MissingInfoHash);
}
```

#### æµ‹è¯•ç”¨ä¾‹ 10ï¼šæ— æ•ˆçš„ info_hash æ ¼å¼

```cpp
TEST(MagnetParserTest, ParseInvalidInfoHashFormat) {
    // é•¿åº¦ä¸å¯¹ï¼ˆåº”è¯¥æ˜¯ 40 ä¸ªåå…­è¿›åˆ¶å­—ç¬¦ï¼‰
    std::string uri = "magnet:?xt=urn:btih:INVALID";
    
    auto result = MagnetUriParser::parse(uri);
    
    ASSERT_TRUE(result.is_err());
    EXPECT_EQ(result.error(), ParseError::InvalidInfoHash);
}
```

#### æµ‹è¯•ç”¨ä¾‹ 11ï¼šæ— æ•ˆçš„ URL ç¼–ç 

```cpp
TEST(MagnetParserTest, ParseInvalidUrlEncoding) {
    std::string uri = "magnet:?xt=urn:btih:ABC&dn=%ZZ";  // æ— æ•ˆçš„ %ZZ
    
    auto result = MagnetUriParser::parse(uri);
    
    ASSERT_TRUE(result.is_err());
    EXPECT_EQ(result.error(), ParseError::InvalidUrlEncoding);
}
```

#### æµ‹è¯•ç”¨ä¾‹ 12ï¼šæ— æ•ˆçš„ URN æ ¼å¼

```cpp
TEST(MagnetParserTest, ParseInvalidUrnFormat) {
    std::string uri = "magnet:?xt=invalid:ABC";  // ä¸æ˜¯ urn:btih:
    
    auto result = MagnetUriParser::parse(uri);
    
    ASSERT_TRUE(result.is_err());
    EXPECT_EQ(result.error(), ParseError::InvalidUrnFormat);
}
```

### 1.4 ç‰¹æ®Šæƒ…å†µæµ‹è¯•

**æµ‹è¯•ç›®æ ‡**ï¼šéªŒè¯ç‰¹æ®Šåœºæ™¯

#### æµ‹è¯•ç”¨ä¾‹ 13ï¼šé‡å¤çš„å‚æ•°ï¼ˆå–æœ€åä¸€ä¸ªï¼‰

```cpp
TEST(MagnetParserTest, ParseDuplicateParameters) {
    std::string uri = "magnet:?xt=urn:btih:ABC&dn=name1&dn=name2&dn=name3";
    
    auto result = MagnetUriParser::parse(uri);
    
    ASSERT_TRUE(result.is_ok());
    EXPECT_EQ(result.value().display_name, "name3");  // å–æœ€åä¸€ä¸ª
}
```

#### æµ‹è¯•ç”¨ä¾‹ 14ï¼šå‚æ•°é¡ºåºä¸åŒ

```cpp
TEST(MagnetParserTest, ParseDifferentParameterOrder) {
    std::string uri1 = "magnet:?xt=urn:btih:ABC&dn=test&tr=http://t.com";
    std::string uri2 = "magnet:?tr=http://t.com&dn=test&xt=urn:btih:ABC";
    
    auto result1 = MagnetUriParser::parse(uri1);
    auto result2 = MagnetUriParser::parse(uri2);
    
    ASSERT_TRUE(result1.is_ok());
    ASSERT_TRUE(result2.is_ok());
    
    // ä¸¤ä¸ªç»“æœåº”è¯¥ç›¸åŒ
    EXPECT_EQ(result1.value().info_hash, result2.value().info_hash);
    EXPECT_EQ(result1.value().display_name, result2.value().display_name);
}
```

#### æµ‹è¯•ç”¨ä¾‹ 15ï¼šåŒ…å«æœªçŸ¥å‚æ•°ï¼ˆåº”è¯¥å¿½ç•¥ï¼‰

```cpp
TEST(MagnetParserTest, ParseUnknownParameters) {
    std::string uri = "magnet:?xt=urn:btih:ABC&unknown=value&future_param=123&dn=test";
    
    auto result = MagnetUriParser::parse(uri);
    
    ASSERT_TRUE(result.is_ok());
    EXPECT_EQ(result.value().display_name, "test");
    // æœªçŸ¥å‚æ•°è¢«å¿½ç•¥ï¼Œä¸å½±å“è§£æ
}
```

#### æµ‹è¯•ç”¨ä¾‹ 16ï¼šåŒ…å«ç©ºå‚æ•°å€¼

```cpp
TEST(MagnetParserTest, ParseEmptyParameterValue) {
    std::string uri = "magnet:?xt=urn:btih:ABC&dn=&tr=http://t.com";
    
    auto result = MagnetUriParser::parse(uri);
    
    ASSERT_TRUE(result.is_ok());
    EXPECT_TRUE(result.value().display_name.empty());
    EXPECT_EQ(result.value().trackers.size(), 1);
}
```

### 1.5 æ€§èƒ½æµ‹è¯•

**æµ‹è¯•ç›®æ ‡**ï¼šéªŒè¯æ€§èƒ½è¦æ±‚

#### æµ‹è¯•ç”¨ä¾‹ 17ï¼šè§£ææ€§èƒ½æµ‹è¯•

```cpp
TEST(MagnetParserTest, ParsePerformance) {
    std::string uri = "magnet:?xt=urn:btih:ABCDEF1234567890&dn=test.mp4&tr=http://tracker.com";
    
    auto start = std::chrono::high_resolution_clock::now();
    
    // è§£æ 10000 æ¬¡
    for (int i = 0; i < 10000; ++i) {
        auto result = MagnetUriParser::parse(uri);
        ASSERT_TRUE(result.is_ok());
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    // æœŸæœ› 10000 æ¬¡è§£æåœ¨ 1 ç§’å†…å®Œæˆ
    EXPECT_LT(duration.count(), 1000);
    
    std::cout << "10000 æ¬¡è§£æè€—æ—¶: " << duration.count() << " ms" << std::endl;
}
```

**æ€§èƒ½ç›®æ ‡**ï¼š
- å•æ¬¡è§£æ < 0.1 ms
- 10000 æ¬¡è§£æ < 1000 ms

---

## 2. Bencode æµ‹è¯•ç”¨ä¾‹

### 2.1 æ•´æ•°ç¼–è§£ç æµ‹è¯•

#### æµ‹è¯•ç”¨ä¾‹ 1ï¼šæ­£æ•°ç¼–ç 

```cpp
TEST(BencodeTest, EncodePositiveInteger) {
    BencodeValue value(42);
    EXPECT_EQ(Bencode::encode(value), "i42e");
}
```

#### æµ‹è¯•ç”¨ä¾‹ 2ï¼šé›¶ç¼–ç 

```cpp
TEST(BencodeTest, EncodeZero) {
    BencodeValue value(0);
    EXPECT_EQ(Bencode::encode(value), "i0e");
}
```

#### æµ‹è¯•ç”¨ä¾‹ 3ï¼šè´Ÿæ•°ç¼–ç 

```cpp
TEST(BencodeTest, EncodeNegativeInteger) {
    BencodeValue value(-3);
    EXPECT_EQ(Bencode::encode(value), "i-3e");
}
```

#### æµ‹è¯•ç”¨ä¾‹ 4ï¼šå¤§æ•´æ•°ç¼–ç 

```cpp
TEST(BencodeTest, EncodeLargeInteger) {
    BencodeValue value(9223372036854775807LL);  // INT64_MAX
    EXPECT_EQ(Bencode::encode(value), "i9223372036854775807e");
}
```

#### æµ‹è¯•ç”¨ä¾‹ 5ï¼šæ•´æ•°è§£ç 

```cpp
TEST(BencodeTest, DecodeInteger) {
    auto result = Bencode::decode("i42e");
    ASSERT_TRUE(result.has_value());
    ASSERT_TRUE(result->is_int());
    EXPECT_EQ(result->as_int(), 42);
}
```

### 2.2 å­—ç¬¦ä¸²ç¼–è§£ç æµ‹è¯•

#### æµ‹è¯•ç”¨ä¾‹ 6ï¼šæ™®é€šå­—ç¬¦ä¸²ç¼–ç 

```cpp
TEST(BencodeTest, EncodeString) {
    BencodeValue value("spam");
    EXPECT_EQ(Bencode::encode(value), "4:spam");
}
```

#### æµ‹è¯•ç”¨ä¾‹ 7ï¼šç©ºå­—ç¬¦ä¸²ç¼–ç 

```cpp
TEST(BencodeTest, EncodeEmptyString) {
    BencodeValue value("");
    EXPECT_EQ(Bencode::encode(value), "0:");
}
```

#### æµ‹è¯•ç”¨ä¾‹ 8ï¼šåŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²

```cpp
TEST(BencodeTest, EncodeStringWithSpecialChars) {
    BencodeValue value("hello\nworld\t!");
    std::string encoded = Bencode::encode(value);
    EXPECT_EQ(encoded.substr(0, 3), "13:");  // é•¿åº¦å‰ç¼€
    
    // éªŒè¯å¯ä»¥è§£ç å›æ¥
    auto decoded = Bencode::decode(encoded);
    ASSERT_TRUE(decoded.has_value());
    EXPECT_EQ(decoded->as_string(), "hello\nworld\t!");
}
```

#### æµ‹è¯•ç”¨ä¾‹ 9ï¼šäºŒè¿›åˆ¶æ•°æ®

```cpp
TEST(BencodeTest, EncodeBinaryData) {
    std::string binary_data = {0x00, 0x01, 0x02, 0xFF};
    BencodeValue value(binary_data);
    std::string encoded = Bencode::encode(value);
    
    auto decoded = Bencode::decode(encoded);
    ASSERT_TRUE(decoded.has_value());
    EXPECT_EQ(decoded->as_string(), binary_data);
}
```

#### æµ‹è¯•ç”¨ä¾‹ 10ï¼šè¶…é•¿å­—ç¬¦ä¸²

```cpp
TEST(BencodeTest, EncodeLongString) {
    std::string long_str(100000, 'x');  // 100KB
    BencodeValue value(long_str);
    std::string encoded = Bencode::encode(value);
    
    auto decoded = Bencode::decode(encoded);
    ASSERT_TRUE(decoded.has_value());
    EXPECT_EQ(decoded->as_string(), long_str);
}
```


### 2.3 åˆ—è¡¨ç¼–è§£ç æµ‹è¯•

#### æµ‹è¯•ç”¨ä¾‹ 11ï¼šç©ºåˆ—è¡¨

```cpp
TEST(BencodeTest, EncodeEmptyList) {
    BencodeList list;
    BencodeValue value(list);
    EXPECT_EQ(Bencode::encode(value), "le");
}
```

#### æµ‹è¯•ç”¨ä¾‹ 12ï¼šæ•´æ•°åˆ—è¡¨

```cpp
TEST(BencodeTest, EncodeIntegerList) {
    BencodeList list;
    list.push_back(BencodeValue(1));
    list.push_back(BencodeValue(2));
    list.push_back(BencodeValue(3));
    
    BencodeValue value(list);
    EXPECT_EQ(Bencode::encode(value), "li1ei2ei3ee");
}
```

#### æµ‹è¯•ç”¨ä¾‹ 13ï¼šå­—ç¬¦ä¸²åˆ—è¡¨

```cpp
TEST(BencodeTest, EncodeStringList) {
    BencodeList list;
    list.push_back(BencodeValue("spam"));
    list.push_back(BencodeValue("eggs"));
    
    BencodeValue value(list);
    EXPECT_EQ(Bencode::encode(value), "l4:spam4:eggse");
}
```

#### æµ‹è¯•ç”¨ä¾‹ 14ï¼šæ··åˆç±»å‹åˆ—è¡¨

```cpp
TEST(BencodeTest, EncodeMixedList) {
    BencodeList list;
    list.push_back(BencodeValue(42));
    list.push_back(BencodeValue("test"));
    list.push_back(BencodeValue(-3));
    
    BencodeValue value(list);
    EXPECT_EQ(Bencode::encode(value), "li42e4:testi-3ee");
}
```

### 2.4 å­—å…¸ç¼–è§£ç æµ‹è¯•

#### æµ‹è¯•ç”¨ä¾‹ 15ï¼šç©ºå­—å…¸

```cpp
TEST(BencodeTest, EncodeEmptyDict) {
    BencodeDict dict;
    BencodeValue value(dict);
    EXPECT_EQ(Bencode::encode(value), "de");
}
```

#### æµ‹è¯•ç”¨ä¾‹ 16ï¼šå•é”®å­—å…¸

```cpp
TEST(BencodeTest, EncodeSingleKeyDict) {
    BencodeDict dict;
    dict["name"] = BencodeValue("test");
    
    BencodeValue value(dict);
    EXPECT_EQ(Bencode::encode(value), "d4:name4:teste");
}
```

#### æµ‹è¯•ç”¨ä¾‹ 17ï¼šå¤šé”®å­—å…¸ï¼ˆéªŒè¯æ’åºï¼‰

```cpp
TEST(BencodeTest, EncodeMultiKeyDict) {
    BencodeDict dict;
    dict["zebra"] = BencodeValue("last");
    dict["apple"] = BencodeValue("first");
    dict["banana"] = BencodeValue("second");
    
    BencodeValue value(dict);
    std::string encoded = Bencode::encode(value);
    
    // å­—å…¸çš„ key åº”è¯¥æŒ‰å­—å…¸åºæ’åº
    EXPECT_EQ(encoded, "d5:apple5:first6:banana6:second5:zebra4:laste");
}
```

### 2.5 åµŒå¥—ç»“æ„æµ‹è¯•

#### æµ‹è¯•ç”¨ä¾‹ 18ï¼šåµŒå¥—åˆ—è¡¨

```cpp
TEST(BencodeTest, EncodeNestedList) {
    BencodeList inner = {BencodeValue(1), BencodeValue(2)};
    BencodeList outer = {BencodeValue(inner), BencodeValue(3)};
    
    BencodeValue value(outer);
    EXPECT_EQ(Bencode::encode(value), "lli1ei2eei3ee");
}
```

#### æµ‹è¯•ç”¨ä¾‹ 19ï¼šå¤æ‚åµŒå¥—ç»“æ„

```cpp
TEST(BencodeTest, EncodeComplexNestedStructure) {
    // æ„é€ ï¼š{"files": ["file1.txt", "file2.txt"], "size": 1024}
    BencodeDict dict;
    dict["name"] = BencodeValue("movie.mp4");
    dict["size"] = BencodeValue(1024000);
    
    BencodeList files;
    files.push_back(BencodeValue("file1.txt"));
    files.push_back(BencodeValue("file2.txt"));
    dict["files"] = BencodeValue(files);
    
    BencodeValue value(dict);
    std::string encoded = Bencode::encode(value);
    
    // éªŒè¯å¯ä»¥è§£ç å›æ¥
    auto decoded = Bencode::decode(encoded);
    ASSERT_TRUE(decoded.has_value());
    ASSERT_TRUE(decoded->is_dict());
    
    const auto& decoded_dict = decoded->as_dict();
    EXPECT_EQ(decoded_dict.at("name").as_string(), "movie.mp4");
    EXPECT_EQ(decoded_dict.at("size").as_int(), 1024000);
    EXPECT_EQ(decoded_dict.at("files").as_list().size(), 2);
}
```

### 2.6 é”™è¯¯å¤„ç†æµ‹è¯•

#### æµ‹è¯•ç”¨ä¾‹ 20ï¼šæ— æ•ˆçš„æ•´æ•°æ ¼å¼

```cpp
TEST(BencodeTest, DecodeInvalidInteger) {
    EXPECT_FALSE(Bencode::decode("i42").has_value());      // ç¼ºå°‘ç»“æŸç¬¦
    EXPECT_FALSE(Bencode::decode("iabce").has_value());    // éæ•°å­—
    EXPECT_FALSE(Bencode::decode("i-0e").has_value());     // è´Ÿé›¶ï¼ˆæ— æ•ˆï¼‰
    EXPECT_FALSE(Bencode::decode("i03e").has_value());     // å‰å¯¼é›¶ï¼ˆæ— æ•ˆï¼‰
}
```

#### æµ‹è¯•ç”¨ä¾‹ 21ï¼šæ— æ•ˆçš„å­—ç¬¦ä¸²æ ¼å¼

```cpp
TEST(BencodeTest, DecodeInvalidString) {
    EXPECT_FALSE(Bencode::decode("5:spam").has_value());   // é•¿åº¦ä¸åŒ¹é…
    EXPECT_FALSE(Bencode::decode("-1:x").has_value());     // è´Ÿæ•°é•¿åº¦
    EXPECT_FALSE(Bencode::decode("abc:test").has_value()); // éæ•°å­—é•¿åº¦
    EXPECT_FALSE(Bencode::decode("10:short").has_value()); // æ•°æ®ä¸è¶³
}
```

#### æµ‹è¯•ç”¨ä¾‹ 22ï¼šä¸å®Œæ•´çš„æ•°æ®

```cpp
TEST(BencodeTest, DecodeIncompleteData) {
    EXPECT_FALSE(Bencode::decode("li1ei2e").has_value());  // åˆ—è¡¨ç¼ºå°‘ç»“æŸç¬¦
    EXPECT_FALSE(Bencode::decode("d4:name").has_value());  // å­—å…¸ä¸å®Œæ•´
    EXPECT_FALSE(Bencode::decode("d4:name4:test").has_value()); // å­—å…¸ç¼ºå°‘ç»“æŸç¬¦
}
```

#### æµ‹è¯•ç”¨ä¾‹ 23ï¼šå­—å…¸ key ä¸æ˜¯å­—ç¬¦ä¸²

```cpp
TEST(BencodeTest, DecodeDictWithNonStringKey) {
    // key å¿…é¡»æ˜¯å­—ç¬¦ä¸²ï¼Œä¸èƒ½æ˜¯æ•´æ•°
    EXPECT_FALSE(Bencode::decode("di1e4:teste").has_value());
}
```

### 2.7 å¾€è¿”æµ‹è¯•ï¼ˆRound-tripï¼‰

#### æµ‹è¯•ç”¨ä¾‹ 24ï¼šæ•´æ•°å¾€è¿”

```cpp
TEST(BencodeTest, RoundTripInteger) {
    BencodeValue original(42);
    std::string encoded = Bencode::encode(original);
    auto decoded = Bencode::decode(encoded);
    
    ASSERT_TRUE(decoded.has_value());
    ASSERT_TRUE(decoded->is_int());
    EXPECT_EQ(decoded->as_int(), 42);
}
```

#### æµ‹è¯•ç”¨ä¾‹ 25ï¼šå¤æ‚ç»“æ„å¾€è¿”

```cpp
TEST(BencodeTest, RoundTripComplexStructure) {
    // æ„é€ å¤æ‚ç»“æ„
    BencodeDict dict;
    dict["name"] = BencodeValue("movie.mp4");
    dict["size"] = BencodeValue(1024000);
    
    BencodeList files;
    files.push_back(BencodeValue("file1.txt"));
    files.push_back(BencodeValue("file2.txt"));
    dict["files"] = BencodeValue(files);
    
    BencodeValue original(dict);
    
    // ç¼–ç 
    std::string encoded = Bencode::encode(original);
    
    // è§£ç 
    auto decoded = Bencode::decode(encoded);
    
    // éªŒè¯
    ASSERT_TRUE(decoded.has_value());
    ASSERT_TRUE(decoded->is_dict());
    
    const auto& decoded_dict = decoded->as_dict();
    EXPECT_EQ(decoded_dict.at("name").as_string(), "movie.mp4");
    EXPECT_EQ(decoded_dict.at("size").as_int(), 1024000);
    ASSERT_TRUE(decoded_dict.at("files").is_list());
    EXPECT_EQ(decoded_dict.at("files").as_list().size(), 2);
}
```

### 2.8 æ€§èƒ½æµ‹è¯•

#### æµ‹è¯•ç”¨ä¾‹ 26ï¼šç¼–ç æ€§èƒ½

```cpp
TEST(BencodeTest, EncodePerformance) {
    BencodeDict dict;
    dict["name"] = BencodeValue("test");
    dict["size"] = BencodeValue(1024);
    BencodeValue value(dict);
    
    auto start = std::chrono::high_resolution_clock::now();
    
    for (int i = 0; i < 100000; ++i) {
        std::string encoded = Bencode::encode(value);
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    // æœŸæœ› 100000 æ¬¡ç¼–ç åœ¨ 1 ç§’å†…å®Œæˆ
    EXPECT_LT(duration.count(), 1000);
}
```

---

## 3. UdpClient æµ‹è¯•ç”¨ä¾‹

### 3.1 åŸºæœ¬åŠŸèƒ½æµ‹è¯•

#### æµ‹è¯•ç”¨ä¾‹ 1ï¼šæ„é€ å’Œææ„

```cpp
TEST(UdpClientTest, Construction) {
    asio::io_context io_context;
    UdpClient client(io_context, 0);
    
    EXPECT_GT(client.local_port(), 0);  // åº”è¯¥åˆ†é…äº†ç«¯å£
    EXPECT_FALSE(client.is_receiving());
}
```

#### æµ‹è¯•ç”¨ä¾‹ 2ï¼šæŒ‡å®šç«¯å£æ„é€ 

```cpp
TEST(UdpClientTest, ConstructionWithSpecificPort) {
    asio::io_context io_context;
    UdpClient client(io_context, 12345);
    
    EXPECT_EQ(client.local_port(), 12345);
}
```

#### æµ‹è¯•ç”¨ä¾‹ 3ï¼šå‘é€å’Œæ¥æ”¶

```cpp
TEST(UdpClientTest, SendAndReceive) {
    asio::io_context io_context;
    UdpClient client(io_context, 0);
    uint16_t port = client.local_port();
    
    bool received = false;
    std::vector<uint8_t> received_data;
    
    // å¼€å§‹æ¥æ”¶
    client.start_receive([&](const UdpMessage& message) {
        received = true;
        received_data = message.data;
    });
    
    // å‘é€åˆ°è‡ªå·±
    UdpEndpoint target("127.0.0.1", port);
    std::vector<uint8_t> send_data = {1, 2, 3, 4};
    
    bool sent = false;
    client.send(target, send_data, [&](const asio::error_code& ec, size_t bytes) {
        sent = !ec;
        EXPECT_EQ(bytes, 4);
    });
    
    // è¿è¡Œ io_context
    io_context.run_for(std::chrono::milliseconds(100));
    
    EXPECT_TRUE(sent);
    EXPECT_TRUE(received);
    EXPECT_EQ(received_data, send_data);
}
```

### 3.2 ç»Ÿè®¡ä¿¡æ¯æµ‹è¯•

#### æµ‹è¯•ç”¨ä¾‹ 4ï¼šç»Ÿè®¡ä¿¡æ¯

```cpp
TEST(UdpClientTest, Statistics) {
    asio::io_context io_context;
    UdpClient client(io_context, 0);
    
    auto stats = client.get_statistics();
    EXPECT_EQ(stats.bytes_sent, 0);
    EXPECT_EQ(stats.bytes_received, 0);
    EXPECT_EQ(stats.messages_sent, 0);
    EXPECT_EQ(stats.messages_received, 0);
}
```

#### æµ‹è¯•ç”¨ä¾‹ 5ï¼šç»Ÿè®¡ä¿¡æ¯æ›´æ–°

```cpp
TEST(UdpClientTest, StatisticsUpdate) {
    asio::io_context io_context;
    UdpClient client(io_context, 0);
    uint16_t port = client.local_port();
    
    client.start_receive([](const UdpMessage&) {});
    
    UdpEndpoint target("127.0.0.1", port);
    std::vector<uint8_t> data = {1, 2, 3, 4};
    
    client.send(target, data, nullptr);
    io_context.run_for(std::chrono::milliseconds(100));
    
    auto stats = client.get_statistics();
    EXPECT_GT(stats.bytes_sent, 0);
    EXPECT_GT(stats.messages_sent, 0);
}
```

### 3.3 ä½¿ç”¨ Mock æµ‹è¯•

#### æµ‹è¯•ç”¨ä¾‹ 6ï¼šMock UdpClient

```cpp
class MockUdpClient {
public:
    MOCK_METHOD(void, send, 
                (const UdpEndpoint&, const std::vector<uint8_t>&, UdpClient::SendCallback));
    MOCK_METHOD(void, start_receive, (UdpClient::ReceiveCallback));
    MOCK_METHOD(void, stop_receive, ());
    MOCK_METHOD(uint16_t, local_port, (), (const));
};

// ä½¿ç”¨ Mock æµ‹è¯• DHT å®¢æˆ·ç«¯
TEST(DHTClientTest, SendPingRequest) {
    MockUdpClient mock_udp;
    DHTClient dht_client(mock_udp);
    
    // æœŸæœ›è°ƒç”¨ send æ–¹æ³•ä¸€æ¬¡
    EXPECT_CALL(mock_udp, send(_, _, _))
        .Times(1);
    
    dht_client.ping("192.168.1.1", 6881);
}
```

---

## 4. æµ‹è¯•è¦†ç›–ç‡ç›®æ ‡

### 4.1 æ¨¡å—è¦†ç›–ç‡ç›®æ ‡

| æ¨¡å— | è¡Œè¦†ç›–ç‡ | åˆ†æ”¯è¦†ç›–ç‡ | å‡½æ•°è¦†ç›–ç‡ | æµ‹è¯•ç”¨ä¾‹æ•° | ä¼˜å…ˆçº§ |
|------|---------|-----------|-----------|-----------|--------|
| **åè®®æ¨¡å—** | 90%+ | 85%+ | 95%+ | 50+ | ğŸ”´ é«˜ |
| Bencode | 95%+ | 90%+ | 100% | 26+ | ğŸ”´ é«˜ |
| MagnetUriParser | 95%+ | 90%+ | 100% | 17+ | ğŸ”´ é«˜ |
| InfoHash | 90%+ | 85%+ | 100% | 10+ | ğŸŸ¡ ä¸­ |
| **ç½‘ç»œæ¨¡å—** | 80%+ | 75%+ | 90%+ | 30+ | ğŸŸ¡ ä¸­ |
| UdpClient | 85%+ | 80%+ | 95%+ | 15+ | ğŸŸ¡ ä¸­ |
| UdpEndpoint | 90%+ | 85%+ | 100% | 8+ | ğŸŸ¢ ä½ |
| **DHT æ¨¡å—** | 85%+ | 80%+ | 90%+ | 40+ | ğŸ”´ é«˜ |
| DHTClient | 90%+ | 85%+ | 95%+ | 25+ | ğŸ”´ é«˜ |
| DHTMessage | 85%+ | 80%+ | 90%+ | 15+ | ğŸŸ¡ ä¸­ |
| **ä¸‹è½½æ¨¡å—** | 80%+ | 75%+ | 90%+ | 35+ | ğŸŸ¡ ä¸­ |
| PeerManager | 85%+ | 80%+ | 95%+ | 20+ | ğŸŸ¡ ä¸­ |
| DownloadManager | 80%+ | 75%+ | 90%+ | 15+ | ğŸŸ¡ ä¸­ |
| **æ•´ä½“é¡¹ç›®** | 85%+ | 80%+ | 90%+ | 150+ | ğŸ”´ é«˜ |

### 4.2 æµ‹è¯•ç”¨ä¾‹åˆ†å¸ƒ

```
æ€»æµ‹è¯•ç”¨ä¾‹ï¼š150+
â”œâ”€â”€ åè®®æ¨¡å—ï¼š50+ (33%)
â”‚   â”œâ”€â”€ Bencodeï¼š26+
â”‚   â”œâ”€â”€ MagnetUriParserï¼š17+
â”‚   â””â”€â”€ InfoHashï¼š10+
â”œâ”€â”€ ç½‘ç»œæ¨¡å—ï¼š30+ (20%)
â”‚   â”œâ”€â”€ UdpClientï¼š15+
â”‚   â””â”€â”€ UdpEndpointï¼š8+
â”œâ”€â”€ DHT æ¨¡å—ï¼š40+ (27%)
â”‚   â”œâ”€â”€ DHTClientï¼š25+
â”‚   â””â”€â”€ DHTMessageï¼š15+
â””â”€â”€ ä¸‹è½½æ¨¡å—ï¼š35+ (23%)
    â”œâ”€â”€ PeerManagerï¼š20+
    â””â”€â”€ DownloadManagerï¼š15+
```

### 4.3 æµ‹è¯•ç±»å‹åˆ†å¸ƒ

- **åŠŸèƒ½æµ‹è¯•**ï¼ˆHappy Pathï¼‰ï¼š40%
- **è¾¹ç•Œæ¡ä»¶æµ‹è¯•**ï¼š25%
- **é”™è¯¯å¤„ç†æµ‹è¯•**ï¼š20%
- **æ€§èƒ½æµ‹è¯•**ï¼š10%
- **é›†æˆæµ‹è¯•**ï¼š5%

---

## 5. æ€»ç»“

### 5.1 æµ‹è¯•ç”¨ä¾‹è®¾è®¡è¦ç‚¹

1. **å…¨é¢æ€§**ï¼šè¦†ç›–æ‰€æœ‰åŠŸèƒ½ç‚¹
2. **è¾¹ç•Œæ€§**ï¼šæµ‹è¯•è¾¹ç•Œæ¡ä»¶
3. **é”™è¯¯æ€§**ï¼šæµ‹è¯•é”™è¯¯å¤„ç†
4. **æ€§èƒ½æ€§**ï¼šæµ‹è¯•æ€§èƒ½è¦æ±‚
5. **å¯ç»´æŠ¤æ€§**ï¼šæµ‹è¯•ä»£ç æ˜“äºç»´æŠ¤

### 5.2 ä¸‹ä¸€æ­¥

1. âœ… å®ç° Bencode ç¼–è§£ç å™¨
2. âœ… ç¼–å†™ Bencode æµ‹è¯•ç”¨ä¾‹
3. âœ… å®ç° MagnetUriParser
4. âœ… ç¼–å†™ MagnetUriParser æµ‹è¯•ç”¨ä¾‹
5. âœ… å®ç° UdpClient
6. âœ… ç¼–å†™ UdpClient æµ‹è¯•ç”¨ä¾‹
7. âœ… è¾¾åˆ°è¦†ç›–ç‡ç›®æ ‡

---

**è¯¦ç»†çš„æµ‹è¯•ç”¨ä¾‹è®¾è®¡å®Œæˆï¼å¯ä»¥å¼€å§‹å®ç°å’Œæµ‹è¯•äº†ã€‚**
