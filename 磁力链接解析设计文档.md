# 磁力链接解析设计文档

## 1. InfoHash 概述

### 1.1 什么是 InfoHash

InfoHash 是 BitTorrent 种子文件的唯一标识符，本质是 **20 字节的 SHA-1 哈希值**。

磁力链接的核心就是这个 InfoHash：
```
magnet:?xt=urn:btih:d0d14c926e6e99761a2fdcff27b403d96376eff6
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                    这就是 InfoHash（40位十六进制 = 20字节）
```

### 1.2 存储方式

```cpp
// 实际存储：永远是 20 字节二进制
std::array<uint8_t, 20> data_;
```

- `uint8_t` 就是 1 个字节（8 位），范围 0-255
- ttttttttttttt20 个 `uint8_t` = 20 字节 = 160 位
- 在内存和网络传输中都使用这个二进制格式

### 1.3 编码格式

同一个 20 字节数据有两种人类可读的编码方式：

| 格式 | 字符数 | 每字符位数 | 示例 |
|------|--------|-----------|------|
| 十六进制 (Hex) | 40 | 4 位 | `d0d14c926e6e99761a2fdcff27b403d96376eff6` |
| Base32 | 32 | 5 位 | `2DIUZETONOEXOGFP3T7SO4ADXFR3N37W` |

**关键理解**：40/32 字符只是"显示格式"，实际存储和使用的永远是 20 字节二进制。

---

## 2. 十六进制 (Hex) 解码

### 2.1 原理

```
16 = 2^4  →  1 个十六进制字符 = 4 位二进制
1 字节 = 8 位 = 2 个十六进制字符
40 字符 × 4 位 = 160 位 = 20 字节
```

### 2.2 字符映射

```
字符: 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
数值: 0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15
```

### 2.3 转换算法

```cpp
int hexCharToValue(char c) {
    if (c >= '0' && c <= '9') return c - '0';        // '0'→0, '9'→9
    if (c >= 'a' && c <= 'f') return c - 'a' + 10;   // 'a'→10, 'f'→15
    if (c >= 'A' && c <= 'F') return c - 'A' + 10;   // 大写也支持
    return -1;  // 非法字符
}
```

### 2.4 转换示例

```
输入: "d0"

'd' → 13 (因为 'd' - 'a' + 10 = 3 + 10 = 13)
'0' → 0

组合: (13 << 4) | 0 = 13 × 16 + 0 = 208

结果: uint8_t = 208 (内存中就是 11010000)
```

### 2.5 完整流程

```
"d0d14c..." (40字符)
    ↓ 每2字符一组
"d0" "d1" "4c" ... (20组)
    ↓ 每组转换成1字节
[208] [209] [76] ... (20字节)
    ↓
std::array<uint8_t, 20>
```

---

## 3. Base32 解码

### 3.1 原理

```
32 = 2^5  →  1 个 Base32 字符 = 5 位二进制
32 字符 × 5 位 = 160 位 = 20 字节
```

### 3.2 字符映射（RFC 4648 标准）

```
字符: A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P
数值: 0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15

字符: Q  R  S  T  U  V  W  X  Y  Z  2  3  4  5  6  7
数值: 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
```

**注意**：不使用 0、1、8、9，因为容易和 O、I 混淆。

### 3.3 转换算法

```cpp
int base32CharToValue(char c) {
    if (c >= 'A' && c <= 'Z') return c - 'A';        // 'A'→0, 'Z'→25
    if (c >= 'a' && c <= 'z') return c - 'a';        // 小写也支持
    if (c >= '2' && c <= '7') return c - '2' + 26;   // '2'→26, '7'→31
    return -1;  // 非法字符（包括 0, 1, 8, 9）
}
```

### 3.4 转换示例

```
输入: "2D"

'2' → 26 → 二进制 11010 (5位)
'D' → 3  → 二进制 00011 (5位)

拼接: 11010 00011 (10位)

按8位分割: 11010000 | 11 (剩余2位留给下一轮)

输出第一个字节: 11010000 = 208
```

### 3.5 完整流程

```
"2DIUZE..." (32字符)
    ↓ 每字符转5位
11010 00011 01000 10100 ... (160位)
    ↓ 按8位分割
11010000 11010001 00010100 ... (20字节)
    ↓
std::array<uint8_t, 20>
```

### 3.6 位累积算法

```cpp
std::optional<InfoHash> fromBase32(std::string_view base32) {
    if (base32.length() != 32) return std::nullopt;
    
    std::array<uint8_t, 20> bytes{};
    int buffer = 0;        // 位缓冲区
    int bitsInBuffer = 0;  // 缓冲区中的位数
    size_t byteIndex = 0;
    
    for (char c : base32) {
        int val = base32CharToValue(c);
        if (val < 0) return std::nullopt;
        
        // 把 5 位加入缓冲区
        buffer = (buffer << 5) | val;
        bitsInBuffer += 5;
        
        // 够 8 位就输出一个字节
        if (bitsInBuffer >= 8) {
            bitsInBuffer -= 8;
            bytes[byteIndex++] = static_cast<uint8_t>(buffer >> bitsInBuffer);
            buffer &= (1 << bitsInBuffer) - 1;  // 保留剩余位
        }
    }
    
    return InfoHash(bytes);
}
```

---

## 4. 磁力链接解析

### 4.1 URI 结构

```
magnet:?xt=urn:btih:ABC123&dn=filename&tr=http://tracker.com
│      │ │                │            │
│      │ └─ 查询参数 ─────┴────────────┘
│      └─ 查询开始符
└─ 协议头
```

### 4.2 参数说明

| 参数 | 含义 | 必需 | 可多个 |
|------|------|------|--------|
| xt | InfoHash (urn:btih:...) | ✓ | ✗ |
| dn | 显示名称 | ✗ | ✗ |
| tr | Tracker URL | ✗ | ✓ |
| xl | 文件大小 | ✗ | ✗ |
| as | Web Seed URL | ✗ | ✓ |
| xs | .torrent 文件源 | ✗ | ✓ |

### 4.3 解析算法（状态机）

```
┌─────────────────────────────────────────────────────────────┐
│ 第一层：URI 结构解析                                          │
├─────────────────────────────────────────────────────────────┤
│ 输入: "magnet:?xt=urn:btih:ABC...&dn=test"                  │
│                                                             │
│ 1. 验证协议头 "magnet:?"                                     │
│ 2. 提取查询字符串: "xt=urn:btih:ABC...&dn=test"             │
└─────────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────────┐
│ 第二层：查询参数解析（状态机）                                  │
├─────────────────────────────────────────────────────────────┤
│ 状态: KEY ←→ VALUE                                          │
│                                                             │
│ 遇到 '=' (且在KEY状态): 切换到 VALUE                         │
│ 遇到 '&' : 保存当前键值对，切换到 KEY                         │
│ 遇到 '%XX' : URL 解码                                       │
│ 遇到 '+' : 替换为空格                                        │
│ 其他字符 : 追加到当前 buffer                                  │
│                                                             │
│ 关键：只按第一个 '=' 分割，后面的 ':' 和 '=' 都是值的一部分     │
└─────────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────────┐
│ 第三层：字段专用解析器                                        │
├─────────────────────────────────────────────────────────────┤
│ xt 字段:                                                    │
│   1. 验证前缀 "urn:btih:"                                   │
│   2. 提取 hash 字符串                                       │
│   3. 根据长度选择解码方式:                                   │
│      - 40 字符 → Hex 解码                                   │
│      - 32 字符 → Base32 解码                                │
│                                                             │
│ 其他字段: 直接使用 URL 解码后的值                             │
└─────────────────────────────────────────────────────────────┘
```

### 4.4 状态机实现

```cpp
enum class State { KEY, VALUE };

std::vector<std::pair<std::string, std::string>>
parseQueryString(std::string_view query) {
    std::vector<std::pair<std::string, std::string>> result;
    
    State state = State::KEY;
    std::string key, value;
    
    for (size_t i = 0; i <= query.size(); ++i) {
        char c = (i < query.size()) ? query[i] : '&';  // 末尾虚拟 &
        
        if (c == '%' && i + 2 < query.size()) {
            // URL 解码: %XX → 字节
            int h = hexCharToValue(query[i + 1]);
            int l = hexCharToValue(query[i + 2]);
            if (h >= 0 && l >= 0) {
                char decoded = static_cast<char>((h << 4) | l);
                (state == State::KEY ? key : value) += decoded;
                i += 2;
                continue;
            }
        }
        
        if (c == '+') {
            (state == State::KEY ? key : value) += ' ';
        }
        else if (c == '=' && state == State::KEY) {
            state = State::VALUE;  // 只在 KEY 状态时切换
        }
        else if (c == '&') {
            if (!key.empty()) {
                result.emplace_back(std::move(key), std::move(value));
            }
            key.clear();
            value.clear();
            state = State::KEY;
        }
        else {
            (state == State::KEY ? key : value) += c;
        }
    }
    
    return result;
}
```

### 4.5 XT 字段解析

```cpp
std::optional<InfoHash> parseXtField(std::string_view value) {
    constexpr std::string_view BTIH_PREFIX = "urn:btih:";
    
    if (value.size() < BTIH_PREFIX.size()) {
        return std::nullopt;
    }
    if (value.substr(0, BTIH_PREFIX.size()) != BTIH_PREFIX) {
        return std::nullopt;
    }
    
    auto hashStr = value.substr(BTIH_PREFIX.size());
    
    switch (hashStr.size()) {
        case 40: return InfoHash::fromHex(hashStr);
        case 32: return InfoHash::fromBase32(hashStr);
        default: return std::nullopt;
    }
}
```

---

## 5. 数据流向总结

```
用户输入磁力链接
    ↓
"magnet:?xt=urn:btih:d0d14c...&dn=test"
    ↓ 解析查询参数
[("xt", "urn:btih:d0d14c..."), ("dn", "test")]
    ↓ 解析 xt 字段
"d0d14c926e6e99761a2fdcff27b403d96376eff6" (40字符)
    ↓ Hex 解码
std::array<uint8_t, 20> = {208, 209, 76, ...}
    ↓ 存入 InfoHash
InfoHash 对象
    ↓ DHT 查询时
直接发送 20 字节二进制数据
```

---

## 6. 关键点总结

1. **InfoHash 本质是 20 字节二进制**，40/32 字符只是编码格式
2. **uint8_t 就是字节**，十进制/十六进制/二进制只是人类看的写法
3. **Hex 解码**：每 2 字符 → 1 字节，简单直接
4. **Base32 解码**：每字符 5 位，累积够 8 位输出 1 字节
5. **URI 解析**：按第一个 `=` 分割，`urn:btih:` 里的 `:` 是值的一部分
6. **状态机**：KEY/VALUE 两状态切换，处理 `&`、`=`、`%XX`、`+`
